{"version":3,"sources":["../../jsglib/layer.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sBAmNe,KAAK","file":"layer.js","sourcesContent":["\"use strict\";\r\n\r\nimport Point from 'jsglib/point';\r\n\r\nclass Layer {\r\n    constructor(name) {\r\n        this.name = name;\r\n\r\n        this.canvas = document.createElement('canvas');\r\n        this.ctx = this.canvas.getContext('2d');\r\n        this.canvas.setAttribute('data-name', this.name);\r\n        this.canvas.style.position = 'absolute';\r\n        this.canvas.style.left = 0;\r\n        this.canvas.style.top = 0;\r\n        this.canvas.style.zIndex = 0;\r\n\r\n        this.tiles_sprite_class = null;\r\n        this.needs_clear = false;\r\n        this.tiles = [];\r\n        this.elements = [];\r\n        this.tiles_animations = [];\r\n    }\r\n\r\n    setSize(width, height) {\r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n        return this;\r\n    }\r\n\r\n    setZindex(new_zindex) {\r\n        this.canvas.style.zIndex = new_zindex;\r\n        return this;\r\n    }\r\n\r\n    getTileFromPoint(point) {\r\n        if (!this.tiles_sprite_class) {\r\n            return null;\r\n        }\r\n\r\n        let tiles_size = this.tiles_sprite_class.getTilesSize();\r\n        let row = this.tiles[Math.floor(point.y / tiles_size.height)];\r\n\r\n        if (!row) {\r\n            return null;\r\n        }\r\n\r\n        return row[Math.floor(point.x / tiles_size.width)] || null;\r\n    }\r\n\r\n    getTilesFromRectangle(rectangle) {\r\n        let tiles = [];\r\n\r\n        if (!this.tiles_sprite_class) {\r\n            return tiles;\r\n        }\r\n\r\n        let tiles_size = this.tiles_sprite_class.getTilesSize();\r\n        let x_min = Math.floor(rectangle.position.x / tiles_size.width);\r\n        let y_min = Math.floor(rectangle.position.y / tiles_size.height);\r\n        let x_max = Math.floor((rectangle.position.x + rectangle.width - 1) / tiles_size.width);\r\n        let y_max = Math.floor((rectangle.position.y + rectangle.height - 1) / tiles_size.height);\r\n\r\n        for (let x = x_min; x <= x_max; x++) {\r\n            for (let y = y_min; y <= y_max; y++) {\r\n                let row = this.tiles[y];\r\n\r\n                if (!row) {\r\n                    continue;\r\n                }\r\n\r\n                let tile = row[x];\r\n\r\n                if (tile) {\r\n                    tiles.push({\r\n                        tile,\r\n                        position: new Point(x * tiles_size.width, y * tiles_size.height)\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return tiles;\r\n    }\r\n\r\n    getAllTilesFromNumber(tile_number) {\r\n        let tiles = [];\r\n\r\n        this.tiles.forEach((row) => {\r\n            row.forEach((tile) => {\r\n                if (tile.tile_number === tile_number) {\r\n                    tiles.push(tile);\r\n                }\r\n            });\r\n        });\r\n\r\n        return tiles;\r\n    }\r\n\r\n    addElement(element) {\r\n        if (element.layer) {\r\n            element.layer.removeElement(element);\r\n        }\r\n\r\n        element.layer = this;\r\n        this.elements.push(element);\r\n        this.needs_clear = true;\r\n\r\n        return this;\r\n    }\r\n\r\n    removeElement(element_to_remove) {\r\n        this.elements.some((element, element_index) => {\r\n            if (element === element_to_remove) {\r\n                this.elements.splice(element_index, 1);\r\n                element_to_remove.layer = null;\r\n                this.needs_clear = true;\r\n                return true;\r\n            }\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    clearTilesAnimations() {\r\n        this.tiles_animations.forEach((animation) => {\r\n            animation.stop();\r\n        });\r\n        this.tiles_animations = [];\r\n        return this;\r\n    }\r\n\r\n    initTilesAnimations(timer) {\r\n        if (!this.tiles_sprite_class) {\r\n            throw new Error('Layer.initTilesAnimation: this layer has no Sprite class for its tiles.');\r\n        }\r\n\r\n        var keys = Array.prototype.concat(\r\n            Object.getOwnPropertyNames(this.tiles_sprite_class.animations),\r\n            Object.getOwnPropertySymbols(this.tiles_sprite_class.animations)\r\n        );\r\n\r\n        keys.forEach((key) => {\r\n            let animation_class = this.tiles_sprite_class.animations[key];\r\n            let animation = new animation_class(timer);\r\n            this.tiles_animations.push(animation);\r\n\r\n            animation\r\n                .on('animation_udpate', () => {\r\n                    this.getAllTilesFromNumber(animation.getPreviousTileNumber()).forEach((tile) => {\r\n                        tile.setTileNumber(animation.getCurrentTileNumber());\r\n                    });\r\n                })\r\n                .start();\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    draw(force_redraw = false) {\r\n        if (this.tiles.length) {\r\n            this.tiles.forEach((row, row_index) => {\r\n                row.forEach((tile, column_index) => {\r\n                    // Draw tile only if we need it\r\n                    if (!force_redraw && !tile.needs_redraw) {\r\n                        return;\r\n                    }\r\n\r\n                    let tiles_size = {\r\n                        width: tile.sprite_class.tiles_width,\r\n                        height: tile.sprite_class.tiles_height\r\n                    };\r\n\r\n                    let dest_x = column_index * tiles_size.width;\r\n                    let dest_y = row_index * tiles_size.height;\r\n\r\n                    tile.needs_redraw = false;\r\n                    tile.clear(this.ctx, dest_x, dest_y);\r\n\r\n                    // If empty tile, we skip it\r\n                    if (tile.is_empty) {\r\n                        return;\r\n                    }\r\n\r\n                    tile.draw(this.ctx, dest_x, dest_y);\r\n                });\r\n            });\r\n\r\n            return this;\r\n        }\r\n\r\n        // No tiles layer: draw elements if any\r\n        if (!force_redraw) {\r\n            return this;\r\n        }\r\n\r\n        this.elements.forEach((element) => {\r\n            element.draw(this.ctx);\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    clear() {\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        return this;\r\n    }\r\n}\r\nLayer.MAIN_LAYER = new Layer('MAIN_LAYER');\r\nLayer.TILES_LAYER = new Layer('TILES_LAYER');\r\nLayer.BACKGROUND_LAYER = new Layer('BACKGROUND_LAYER');\r\n\r\nexport default Layer;"]}