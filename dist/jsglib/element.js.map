{"version":3,"sources":["../../jsglib/element.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QAMqB,OAAO;kBAAP,OAAO;;iBAAP,OAAO;kCAAP,OAAO;;+EAAP,OAAO;;;;;;;;;;;;;qBAAP,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;eAAP,OAAO;;;sBAAP,OAAO","file":"element.js","sourcesContent":["\"use strict\";\r\n\r\nimport EventsHandler from 'jsglib/events_handler';\r\nimport Point from \"jsglib/point\";\r\nimport Rectangle from \"jsglib/rectangle\";\r\n\r\nexport default class Element extends EventsHandler {\r\n    constructor(x, y) {\r\n        super();\r\n        this.prev_position = new Point(x, y);\r\n        this.position = new Point(x, y);\r\n        this.layer = null;\r\n        this.sprite_class = null;\r\n        this.current_tile = null;\r\n        this.current_animation = null;\r\n        this.speed = new Point();\r\n        this.stop_on_solids = false;\r\n    }\r\n\r\n    setSpriteClass(sprite_class) {\r\n        this.sprite_class = sprite_class;\r\n        this.current_tile = sprite_class.getTile(1);\r\n        return this;\r\n    }\r\n\r\n    setCurrentTileNumber(tile_number) {\r\n        this.current_tile = this.sprite_class.getTile(tile_number);\r\n\r\n        if (this.layer) {\r\n            this.layer.needs_clear = true;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    useAnimation(animation_name, time, loop = true, timer = null) {\r\n        if (this.current_animation) {\r\n            if (this.getAnimationName() === animation_name) {\r\n                return this;\r\n            }\r\n\r\n            this.current_animation.stop();\r\n        }\r\n\r\n        let animation_class = this.sprite_class.getAnimationClass(animation_name);\r\n\r\n        if (!animation_class) {\r\n            throw new ReferenceError('Element.useAnimation: animation \"' + animation_name + '\" is not defined for sprite \"' + this.sprite_class.name + '\".');\r\n        }\r\n\r\n        this.current_animation = new animation_class(timer);\r\n\r\n        this.setCurrentTileNumber(this.current_animation.getCurrentTileNumber());\r\n\r\n        this.current_animation\r\n            .on('animation_udpate', () => {\r\n                this.setCurrentTileNumber(this.current_animation.getCurrentTileNumber());\r\n            })\r\n            .start(time, loop);\r\n\r\n        return this;\r\n    }\r\n\r\n    getAnimationName() {\r\n       return this.current_animation ? this.current_animation.name : '';\r\n    }\r\n\r\n    getSize() {\r\n        let {width, height} = this.getRectangle();\r\n        return {width, height};\r\n    }\r\n\r\n    draw(ctx) {\r\n        this.current_tile.draw(ctx, this.position.x, this.position.y);\r\n        return this;\r\n    }\r\n\r\n    getRectangle() {\r\n        let size = this.sprite_class ? this.sprite_class.getTilesSize() : {};\r\n        return new Rectangle(size.width, size.height, this.position);\r\n    }\r\n\r\n    move() {\r\n        this.position.add(this.speed, false);\r\n        return this;\r\n    }\r\n\r\n    checkCollisions(layers) {\r\n        var has_solid_collision = false;\r\n\r\n        for (var layer_name in layers) {\r\n            let layer = layers[layer_name];\r\n\r\n            // First, check tiles collisions\r\n            let collisions_data = this.checkTilesCollisions(layer);\r\n\r\n            // Check collisions with solid tiles\r\n            if (this.stop_on_solids && collisions_data.solid_collision) {\r\n                has_solid_collision = true;\r\n                this.refinePosition(layer, this.checkTilesCollisions);\r\n            }\r\n\r\n            // Trigger collision events for each tile\r\n            collisions_data.tiles.some((tile_data) => {\r\n                let custom_event = this.trigger('tile_collision', {tile_data});\r\n                return custom_event.propagationStopped;\r\n            });\r\n        }\r\n\r\n        if (!has_solid_collision) {\r\n            this.trigger('no_solids_collision');\r\n        }\r\n    }\r\n\r\n    checkTilesCollisions(layer, position = this.position) {\r\n        let data = {\r\n            tiles: [],\r\n            solid_collision: false\r\n        };\r\n\r\n        if (!layer.tiles.length) {\r\n            return data;\r\n        }\r\n\r\n        let rectangle = this.getRectangle();\r\n        rectangle.position.copy(position);\r\n\r\n        data.tiles = layer.getTilesFromRectangle(rectangle);\r\n\r\n        data.solid_collision = data.tiles.some(tile_data => tile_data.tile.isSolid());\r\n\r\n        return data;\r\n    }\r\n\r\n    refinePosition(layer, checkCollisionsMethod) {\r\n        let delta_position = this.position.substract(this.prev_position);\r\n        let limit_x = Math.abs(delta_position.x);\r\n        let limit_y = Math.abs(delta_position.y);\r\n        let delta_x = Math.sign(delta_position.x);\r\n        let delta_y = Math.sign(delta_position.y);\r\n        let new_position = this.prev_position.clone();\r\n\r\n        // Refine X\r\n        for (let x = 0; x < limit_x; x++) {\r\n            new_position.x += delta_x;\r\n\r\n            if (checkCollisionsMethod.call(this, layer, new_position).solid_collision) {\r\n                new_position.x -= delta_x;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Refine Y\r\n        for (let y = 0; y < limit_y; y++) {\r\n            new_position.y += delta_y;\r\n\r\n            if (checkCollisionsMethod.call(this, layer, new_position).solid_collision) {\r\n                new_position.y -= delta_y;\r\n                break;\r\n            }\r\n        }\r\n\r\n        this.position.copy(new_position);\r\n    }\r\n}"]}