{"version":3,"sources":["../../jsglib/sprite.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBA4Ge,MAAM","file":"sprite.js","sourcesContent":["\"use strict\";\r\n\r\nimport Tile from \"jsglib/tile\";\r\n\r\nclass Sprite {\r\n\tconstructor() {\r\n\t\tthis.image = this.constructor.image;\r\n\t}\r\n\tgetTilesSize() {\r\n\t\treturn this.constructor.getTilesSize();\r\n\t}\r\n\tstatic getTilesSize() {\r\n\t\treturn {\r\n\t\t\twidth: this.tiles_width || 0,\r\n\t\t\theight: this.tiles_height || 0\r\n\t\t};\r\n\t}\r\n\tstatic getTile(tile_number, clone = true) {\r\n\t\ttile_number--;\r\n\r\n\t\tif (tile_number < 0) {\r\n\t\t\treturn new Tile(null);\r\n\t\t}\r\n\r\n\t\tlet tiles = this.tiles;\r\n\t\tlet total_columns = tiles[0].length;\r\n\r\n\t\tlet row_index = Math.floor(tile_number / total_columns);\r\n\t\tlet column_index = tile_number % total_columns;\r\n\r\n\t\tlet tile = tiles[row_index][column_index];\r\n\r\n\t\tif ( ! tile) {\r\n\t\t\treturn new Tile(null);\r\n\t\t}\r\n\r\n\t\treturn clone ? tiles[row_index][column_index].clone() : tiles[row_index][column_index];\r\n\t}\r\n\tstatic loadImage(url) {\r\n\t\tlet promise = (resolve, reject) => {\r\n\t\t\tthis.image = new Image();\r\n\r\n\t\t\tthis.image.onload = () => {\r\n\t\t\t\tresolve(this.image);\r\n\t\t\t};\r\n\r\n\t\t\tthis.image.onerror = reject;\r\n\t\t\tthis.image.src = url;\r\n\t\t};\r\n\r\n\t\treturn new Promise(promise);\r\n\t}\r\n\tstatic makeTiles(tiles_width = 16, tiles_height = 16, tiles_separation = 1) {\r\n\t\tif (!this.image) {\r\n\t\t\tthrow ReferenceError(this.name + '.makeTiles(): image not found for this class');\r\n\t\t}\r\n\r\n\t\tthis.tiles = [];\r\n\t\tthis.tiles_width = tiles_width;\r\n\t\tthis.tiles_height = tiles_height;\r\n\t\tthis.tiles_separation = tiles_separation;\r\n\r\n\t\tlet image_width = this.image.naturalWidth;\r\n\t\tlet image_height = this.image.naturalHeight;\r\n\r\n\t\tfor (let j = 0; j < image_height; j += tiles_height) {\r\n\t\t\tlet x = j / tiles_height;\r\n\t\t\tthis.tiles[x] = [];\r\n\r\n\t\t\tfor (let i = 0; i < image_width; i += tiles_width) {\r\n\t\t\t\tthis.tiles[x][i / tiles_width] = new Tile(\r\n\t\t\t\t\tthis,\r\n\t\t\t\t\ti + tiles_separation * (i / tiles_width),\r\n\t\t\t\t\tj + tiles_separation * (j / tiles_height)\r\n\t\t\t\t);\r\n\t\t\t\timage_width -= tiles_separation;\r\n\t\t\t}\r\n\t\t\timage_width = this.image.naturalWidth;\r\n\t\t\timage_height -= tiles_separation;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\tstatic defineTilesAnimations(...animations) {\r\n\t\tfor (let animation of animations) {\r\n\t\t\tanimation.tiles.forEach((tile_number, index) => {\r\n\t\t\t\tlet current_animated_tile = this.getTile(tile_number, false);\r\n\t\t\t\tlet next_tile_number = animation.tiles[index + 1] || animation.tiles[0];\r\n\r\n\t\t\t\tcurrent_animated_tile.setAnimation(next_tile_number, animation.time);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\tstatic defineTilesTypes(...types) {\r\n\t\tfor (let type of types) {\r\n\t\t\t// TODO\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\nSprite.TILES_TYPES = {\r\n\tWALL: Symbol()\r\n};\r\n\r\nexport default Sprite;"]}