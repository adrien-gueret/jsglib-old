{"version":3,"sources":["../../jsglib/sprite.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sBAqHe,MAAM","file":"sprite.js","sourcesContent":["\"use strict\";\r\n\r\nimport Tile from \"jsglib/tile\";\r\nimport Animation from \"jsglib/animation\";\r\n\r\nclass Sprite {\r\n    static getTilesSize() {\r\n        return {\r\n            width: this.tiles_width || 0,\r\n            height: this.tiles_height || 0\r\n        };\r\n    }\r\n\r\n    static getTile(tile_number, clone = true) {\r\n        tile_number--;\r\n\r\n        if (tile_number < 0) {\r\n            return Tile.getNewEmptyTile(this);\r\n        }\r\n\r\n        let tiles = this.tiles;\r\n        let total_columns = tiles[0].length;\r\n\r\n        let row_index = Math.floor(tile_number / total_columns);\r\n        let column_index = tile_number % total_columns;\r\n\r\n        let tile = tiles[row_index] ? tiles[row_index][column_index] : null;\r\n\r\n        if (!tile) {\r\n            return Tile.getNewEmptyTile(this);\r\n        }\r\n\r\n        return clone ? tiles[row_index][column_index].clone() : tiles[row_index][column_index];\r\n    }\r\n\r\n    static loadImage(url) {\r\n        let promise = (resolve, reject) => {\r\n            this.image = new Image();\r\n\r\n            this.image.onload = () => {\r\n                resolve(this.image);\r\n            };\r\n\r\n            this.image.onerror = reject;\r\n            this.image.src = url;\r\n        };\r\n\r\n        return new Promise(promise);\r\n    }\r\n\r\n    static makeTiles(tiles_width = 16, tiles_height = 16, tiles_separation = 1) {\r\n        if (!this.image) {\r\n            throw ReferenceError(this.name + '.makeTiles(): image not found for this class');\r\n        }\r\n\r\n        this.tiles = [];\r\n        this.tiles_width = tiles_width;\r\n        this.tiles_height = tiles_height;\r\n        this.tiles_separation = tiles_separation;\r\n\r\n        let image_width = this.image.naturalWidth;\r\n        let image_height = this.image.naturalHeight;\r\n        let tile_number = 1;\r\n\r\n        for (let j = 0; j < image_height; j += tiles_height) {\r\n            let x = j / tiles_height;\r\n            this.tiles[x] = [];\r\n\r\n            for (let i = 0; i < image_width; i += tiles_width) {\r\n                this.tiles[x][i / tiles_width] = new Tile(\r\n                    this,\r\n                    i + tiles_separation * (i / tiles_width),\r\n                    j + tiles_separation * (j / tiles_height),\r\n                    tile_number++\r\n                );\r\n                image_width -= tiles_separation;\r\n            }\r\n            image_width = this.image.naturalWidth;\r\n            image_height -= tiles_separation;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    static defineTilesAnimations(animations, timer) {\r\n        this.animations = {};\r\n\r\n        animations.forEach((animation) => {\r\n            this.animations[animation.name || Symbol()] = Animation.define(timer, animation.tiles, animation.time);\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    static getAnimationClass(animation_name) {\r\n        return this.animations[animation_name] || null;\r\n    }\r\n\r\n    static defineTilesTypes(types) {\r\n        types.forEach((type) => {\r\n            // TODO\r\n        });\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nSprite.image = null;\r\nSprite.tiles = [];\r\nSprite.tiles_width = 0;\r\nSprite.tiles_height = 0;\r\nSprite.animations = {};\r\n\r\nSprite.TILES_TYPES = {\r\n    SOLID: Symbol()\r\n};\r\n\r\nexport default Sprite;"]}