{"version":3,"sources":["../../jsglib/sprite.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sBAmHe,MAAM","file":"sprite.js","sourcesContent":["\"use strict\";\r\n\r\nimport Tile from \"jsglib/tile\";\r\n\r\nclass Sprite {\r\n    constructor() {\r\n        this.image = this.constructor.image;\r\n    }\r\n\r\n    getTilesSize() {\r\n        return this.constructor.getTilesSize();\r\n    }\r\n\r\n    static getTilesSize() {\r\n        return {\r\n            width: this.tiles_width || 0,\r\n            height: this.tiles_height || 0\r\n        };\r\n    }\r\n\r\n    static getTile(tile_number, clone = true) {\r\n        tile_number--;\r\n\r\n        if (tile_number < 0) {\r\n            return new Tile(null);\r\n        }\r\n\r\n        let tiles = this.tiles;\r\n        let total_columns = tiles[0].length;\r\n\r\n        let row_index = Math.floor(tile_number / total_columns);\r\n        let column_index = tile_number % total_columns;\r\n\r\n        let tile = tiles[row_index][column_index];\r\n\r\n        if (!tile) {\r\n            return new Tile(null);\r\n        }\r\n\r\n        return clone ? tiles[row_index][column_index].clone() : tiles[row_index][column_index];\r\n    }\r\n\r\n    static loadImage(url) {\r\n        let promise = (resolve, reject) => {\r\n            this.image = new Image();\r\n\r\n            this.image.onload = () => {\r\n                resolve(this.image);\r\n            };\r\n\r\n            this.image.onerror = reject;\r\n            this.image.src = url;\r\n        };\r\n\r\n        return new Promise(promise);\r\n    }\r\n\r\n    static makeTiles(tiles_width = 16, tiles_height = 16, tiles_separation = 1) {\r\n        if (!this.image) {\r\n            throw ReferenceError(this.name + '.makeTiles(): image not found for this class');\r\n        }\r\n\r\n        this.tiles = [];\r\n        this.tiles_width = tiles_width;\r\n        this.tiles_height = tiles_height;\r\n        this.tiles_separation = tiles_separation;\r\n\r\n        let image_width = this.image.naturalWidth;\r\n        let image_height = this.image.naturalHeight;\r\n\r\n        for (let j = 0; j < image_height; j += tiles_height) {\r\n            let x = j / tiles_height;\r\n            this.tiles[x] = [];\r\n\r\n            for (let i = 0; i < image_width; i += tiles_width) {\r\n                this.tiles[x][i / tiles_width] = new Tile(\r\n                    this,\r\n                    i + tiles_separation * (i / tiles_width),\r\n                    j + tiles_separation * (j / tiles_height)\r\n                );\r\n                image_width -= tiles_separation;\r\n            }\r\n            image_width = this.image.naturalWidth;\r\n            image_height -= tiles_separation;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    static defineTilesAnimations(...animations) {\r\n        for (let animation of animations) {\r\n            animation.tiles.forEach((tile_number, index) => {\r\n                let current_animated_tile = this.getTile(tile_number, false);\r\n                let next_tile_number = animation.tiles[index + 1] || animation.tiles[0];\r\n\r\n                current_animated_tile.setAnimation(next_tile_number, animation.time);\r\n            });\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    static defineTilesTypes(...types) {\r\n        for (let type of types) {\r\n            // TODO\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nSprite.TILES_TYPES = {\r\n    WALL: Symbol()\r\n};\r\n\r\nexport default Sprite;"]}